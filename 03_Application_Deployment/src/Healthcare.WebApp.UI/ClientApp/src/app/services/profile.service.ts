/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { ProfileStatus } from '../models/profile-status';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ProfileService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param citizenProfile (optional) 
     * @return Success
     */
    deployProfile(citizenProfile: Profile | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/CreateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(citizenProfile);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeployProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeployProfile(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processDeployProfile(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @param docProof (optional) 
     * @return Success
     */
    updateProfile(citizenIdentifier: string | null | undefined, docProof: DocProof | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/UpdateProfile?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(docProof);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @return Success
     */
    getCitizenProfile(citizenIdentifier: string | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/GetCitizenProfile?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCitizenProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitizenProfile(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitizenProfile(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param citizenidentifier (optional) 
     * @param healthcareplan (optional) 
     * @return Success
     */
    assignHealthCarePlan(citizenidentifier: string | null | undefined, healthcareplan: HealthcarePlan | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/AssignHealthCarePlan?";
        if (citizenidentifier !== undefined)
            url_ += "citizenidentifier=" + encodeURIComponent("" + citizenidentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(healthcareplan);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAssignHealthCarePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignHealthCarePlan(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processAssignHealthCarePlan(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @param state (optional) 
     * @return Success
     */
    resetActiveState(citizenIdentifier: string | null | undefined, state: string | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/ResetActiveState?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetActiveState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetActiveState(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processResetActiveState(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @return Success
     */
    approveHealthcarePlan(citizenIdentifier: string | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/ApproveHealthcarePlan?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processApproveHealthcarePlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveHealthcarePlan(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processApproveHealthcarePlan(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @param citizenIdentifier (optional) 
     * @return Success
     */
    updateProofDocument(proofDoc: File, citizenIdentifier: string | null | undefined): Observable<DocProof> {
        let url_ = this.baseUrl + "/api/ProfileService/UpdateProofDocument?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const formData = new FormData();
        formData.append('proofDoc', proofDoc, proofDoc.name);

        return this.http.post<DocProof>(url_, formData);
        // return this.http.post(url_, formData).pipe(_observableMergeMap((response_: any) => {
        //     return this.processUpdateProofDocument(response_);
        // })).pipe(_observableCatch((response_: any) => {
        //     if (response_ instanceof HttpResponseBase) {
        //         try {
        //             return this.processUpdateProofDocument(<any>response_);
        //         } catch (e) {
        //             return <Observable<DocProof>><any>_observableThrow(e);
        //         }
        //     } else
        //         return <Observable<DocProof>><any>_observableThrow(response_);
        // }));
    }

    protected processUpdateProofDocument(response: HttpResponseBase): Observable<DocProof> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DocProof.fromJS(resultData200) : new DocProof();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocProof>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @return Success
     */
    getProofDocumentUrl(citizenIdentifier: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/ProfileService/GetProofDocument?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProofDocumentUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProofDocumentUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetProofDocumentUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @param hash (optional) 
     * @return Success
     */
    validateProofDocumentHash(citizenIdentifier: string | null | undefined, hash: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfileService/ValidateProofDocumentHash?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        if (hash !== undefined)
            url_ += "hash=" + encodeURIComponent("" + hash) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processValidateProofDocumentHash(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateProofDocumentHash(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateProofDocumentHash(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param citizenIdentifier (optional) 
     * @return Success
     */
    getTransactionsByCitizenIdentifier(citizenIdentifier: string | null | undefined): Observable<ContractTransaction[]> {
        let url_ = this.baseUrl + "/api/ProfileService/GetTransactionsByCitizenIdentifier?";
        if (citizenIdentifier !== undefined)
            url_ += "citizenIdentifier=" + encodeURIComponent("" + citizenIdentifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTransactionsByCitizenIdentifier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsByCitizenIdentifier(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionsByCitizenIdentifier(response: HttpResponseBase): Observable<ContractTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ContractTransaction.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction[]>(<any>null);
    }

    /**
     * @param entityId (optional) 
     * @return Success
     */
    getTransactionByEntityId(entityId: string | null | undefined): Observable<ContractTransaction> {
        let url_ = this.baseUrl + "/api/ProfileService/GetTransactionByEntityId?";
        if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTransactionByEntityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionByEntityId(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionByEntityId(response: HttpResponseBase): Observable<ContractTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContractTransaction.fromJS(resultData200) : new ContractTransaction();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction>(<any>null);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getCompletedCitizenProfiles(state: string | null | undefined): Observable<ContractTransaction[]> {
        let url_ = this.baseUrl + "/api/ProfileService/GetCompletedCitizenProfiles?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCompletedCitizenProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompletedCitizenProfiles(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompletedCitizenProfiles(response: HttpResponseBase): Observable<ContractTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ContractTransaction.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction[]>(<any>null);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getIncompletedCitizenProfiles(state: string | null | undefined): Observable<ContractTransaction[]> {
        let url_ = this.baseUrl + "/api/ProfileService/GetIncompletedCitizenProfiles?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetIncompletedCitizenProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncompletedCitizenProfiles(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncompletedCitizenProfiles(response: HttpResponseBase): Observable<ContractTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ContractTransaction.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction[]>(<any>null);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getCitizenProfiles(state: string | null | undefined): Observable<ContractTransaction[]> {
        let url_ = this.baseUrl + "/api/ProfileService/GetCitizenProfiles?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCitizenProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitizenProfiles(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitizenProfiles(response: HttpResponseBase): Observable<ContractTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ContractTransaction.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction[]>(<any>null);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getCitizenProfilesNotApprovedHealthcareplan(state: string | null | undefined): Observable<ContractTransaction[]> {
        let url_ = this.baseUrl + "/api/ProfileService/GetCitizenProfilesNotApprovedHealthcareplan?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCitizenProfilesNotApprovedHealthcareplan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitizenProfilesNotApprovedHealthcareplan(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitizenProfilesNotApprovedHealthcareplan(response: HttpResponseBase): Observable<ContractTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ContractTransaction.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction[]>(<any>null);
    }

    /**
     * @param state (optional) 
     * @return Success
     */
    getCitizenProfilesApprovedHealthcareplan(state: string | null | undefined): Observable<ContractTransaction[]> {
        let url_ = this.baseUrl + "/api/ProfileService/GetCitizenProfilesApprovedHealthcareplan?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCitizenProfilesApprovedHealthcareplan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitizenProfilesApprovedHealthcareplan(<any>response_);
                } catch (e) {
                    return <Observable<ContractTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCitizenProfilesApprovedHealthcareplan(response: HttpResponseBase): Observable<ContractTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ContractTransaction.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTransaction[]>(<any>null);
    }
}

export class Profile implements IProfile {
    transactionID?: string | undefined;
    transactedTime?: Date | undefined;
    description?: string | undefined;
    citizenIdentifier?: string | undefined;
    basicProfile?: BasicProfileItem | undefined;
    identifyProofs?: DocProof | undefined;
    preferredHealthcarePlan?: HealthcarePlanItem | undefined;
    status?: ProfileStatus | undefined;
    activeState?: string | undefined;
    stateApprover?: string | undefined;
    currentHealthcarePlan?: HealthcarePlan | undefined;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionID = data["transactionID"];
            this.transactedTime = data["transactedTime"] ? new Date(data["transactedTime"].toString()) : <any>undefined;
            this.description = data["description"];
            this.citizenIdentifier = data["citizenIdentifier"];
            this.basicProfile = data["basicProfile"] ? BasicProfileItem.fromJS(data["basicProfile"]) : <any>undefined;
            this.identifyProofs = data["identifyProofs"] ? DocProof.fromJS(data["identifyProofs"]) : <any>undefined;
            this.preferredHealthcarePlan = data["preferredHealthcarePlan"] ? HealthcarePlanItem.fromJS(data["preferredHealthcarePlan"]) : <any>undefined;
            this.status = data["status"];
            this.activeState = data["activeState"];
            this.stateApprover = data["stateApprover"];
            this.currentHealthcarePlan = data["currentHealthcarePlan"] ? HealthcarePlan.fromJS(data["currentHealthcarePlan"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionID"] = this.transactionID;
        data["transactedTime"] = this.transactedTime ? this.transactedTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["citizenIdentifier"] = this.citizenIdentifier;
        data["basicProfile"] = this.basicProfile ? this.basicProfile.toJSON() : <any>undefined;
        data["identifyProofs"] = this.identifyProofs ? this.identifyProofs.toJSON() : <any>undefined;
        data["preferredHealthcarePlan"] = this.preferredHealthcarePlan ? this.preferredHealthcarePlan.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["activeState"] = this.activeState;
        data["stateApprover"] = this.stateApprover;
        data["currentHealthcarePlan"] = this.currentHealthcarePlan ? this.currentHealthcarePlan.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProfile {
    transactionID?: string | undefined;
    transactedTime?: Date | undefined;
    description?: string | undefined;
    citizenIdentifier?: string | undefined;
    basicProfile?: BasicProfileItem | undefined;
    identifyProofs?: DocProof | undefined;
    preferredHealthcarePlan?: HealthcarePlanItem | undefined;
    status?: ProfileStatus | undefined;
    activeState?: string | undefined;
    stateApprover?: string | undefined;
    currentHealthcarePlan?: HealthcarePlan | undefined;
}

export class BasicProfileItem implements IBasicProfileItem {
    name?: string | undefined;
    address?: Address | undefined;
    dateOfBirth?: Date | undefined;
    citizenShip?: boolean | undefined;
    fedIncome?: number | undefined;
    stateIncome?: number | undefined;
    applicationType?: BasicProfileItemApplicationType | undefined;

    constructor(data?: IBasicProfileItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.citizenShip = data["citizenShip"];
            this.fedIncome = data["fedIncome"];
            this.stateIncome = data["stateIncome"];
            this.applicationType = data["applicationType"];
        }
    }

    static fromJS(data: any): BasicProfileItem {
        data = typeof data === 'object' ? data : {};
        let result = new BasicProfileItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["citizenShip"] = this.citizenShip;
        data["fedIncome"] = this.fedIncome;
        data["stateIncome"] = this.stateIncome;
        data["applicationType"] = this.applicationType;
        return data;
    }
}

export interface IBasicProfileItem {
    name?: string | undefined;
    address?: Address | undefined;
    dateOfBirth?: Date | undefined;
    citizenShip?: boolean | undefined;
    fedIncome?: number | undefined;
    stateIncome?: number | undefined;
    applicationType?: BasicProfileItemApplicationType | undefined;
}

export class DocProof implements IDocProof {
    fileName?: string | undefined;
    hash?: string | undefined;
    contentType?: string | undefined;
    container?: string | undefined;
    storageSharding?: string | undefined;

    constructor(data?: IDocProof) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.hash = data["hash"];
            this.contentType = data["contentType"];
            this.container = data["container"];
            this.storageSharding = data["storageSharding"];
        }
    }

    static fromJS(data: any): DocProof {
        data = typeof data === 'object' ? data : {};
        let result = new DocProof();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["hash"] = this.hash;
        data["contentType"] = this.contentType;
        data["container"] = this.container;
        data["storageSharding"] = this.storageSharding;
        return data;
    }
}

export interface IDocProof {
    fileName?: string | undefined;
    hash?: string | undefined;
    contentType?: string | undefined;
    container?: string | undefined;
    storageSharding?: string | undefined;
}

export class HealthcarePlanItem implements IHealthcarePlanItem {
    name?: string | undefined;
    id?: string | undefined;

    constructor(data?: IHealthcarePlanItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HealthcarePlanItem {
        data = typeof data === 'object' ? data : {};
        let result = new HealthcarePlanItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IHealthcarePlanItem {
    name?: string | undefined;
    id?: string | undefined;
}

export class HealthcarePlan implements IHealthcarePlan {
    healthcareStatus?: HealthcarePlanHealthcareStatus | undefined;
    plan?: HealthcarePlanItem | undefined;
    ownerState?: string | undefined;
    enrollmentBorkerAssigedState?: string | undefined;
    carePlanEligibilityStatus?: HealthcarePlanCarePlanEligibilityStatus | undefined;
    planApprover?: string | undefined;
    approved?: boolean | undefined;
    assignedDate?: Date | undefined;
    enrolledDate?: Date | undefined;
    approvedDate?: Date | undefined;
    eligible?: boolean | undefined;

    constructor(data?: IHealthcarePlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.healthcareStatus = data["healthcareStatus"];
            this.plan = data["plan"] ? HealthcarePlanItem.fromJS(data["plan"]) : <any>undefined;
            this.ownerState = data["ownerState"];
            this.enrollmentBorkerAssigedState = data["enrollmentBorkerAssigedState"];
            this.carePlanEligibilityStatus = data["carePlanEligibilityStatus"];
            this.planApprover = data["planApprover"];
            this.approved = data["approved"];
            this.assignedDate = data["assignedDate"] ? new Date(data["assignedDate"].toString()) : <any>undefined;
            this.enrolledDate = data["enrolledDate"] ? new Date(data["enrolledDate"].toString()) : <any>undefined;
            this.approvedDate = data["approvedDate"] ? new Date(data["approvedDate"].toString()) : <any>undefined;
            this.eligible = data["eligible"];
        }
    }

    static fromJS(data: any): HealthcarePlan {
        data = typeof data === 'object' ? data : {};
        let result = new HealthcarePlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["healthcareStatus"] = this.healthcareStatus;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["ownerState"] = this.ownerState;
        data["enrollmentBorkerAssigedState"] = this.enrollmentBorkerAssigedState;
        data["carePlanEligibilityStatus"] = this.carePlanEligibilityStatus;
        data["planApprover"] = this.planApprover;
        data["approved"] = this.approved;
        data["assignedDate"] = this.assignedDate ? this.assignedDate.toISOString() : <any>undefined;
        data["enrolledDate"] = this.enrolledDate ? this.enrolledDate.toISOString() : <any>undefined;
        data["approvedDate"] = this.approvedDate ? this.approvedDate.toISOString() : <any>undefined;
        data["eligible"] = this.eligible;
        return data;
    }
}

export interface IHealthcarePlan {
    healthcareStatus?: HealthcarePlanHealthcareStatus | undefined;
    plan?: HealthcarePlanItem | undefined;
    ownerState?: string | undefined;
    enrollmentBorkerAssigedState?: string | undefined;
    carePlanEligibilityStatus?: HealthcarePlanCarePlanEligibilityStatus | undefined;
    planApprover?: string | undefined;
    approved?: boolean | undefined;
    assignedDate?: Date | undefined;
    enrolledDate?: Date | undefined;
    approvedDate?: Date | undefined;
    eligible?: boolean | undefined;
}

export class Address implements IAddress {
    street?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.street = data["street"];
            this.city = data["city"];
            this.state = data["state"];
            this.zip = data["zip"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zip"] = this.zip;
        return data;
    }
}

export interface IAddress {
    street?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    zip?: string | undefined;
}

export class ContractTransaction implements IContractTransaction {
    id?: string | undefined;
    isActiveTransaction?: boolean | undefined;
    contractID?: string | undefined;
    transactionID?: string | undefined;
    businessContractDTO?: Profile | undefined;
    transactionTime?: Date | undefined;
    transactionConfirmation?: TransactionConfirmation | undefined;
    name?: string | undefined;
    bindingId?: string | undefined;

    constructor(data?: IContractTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.isActiveTransaction = data["isActiveTransaction"];
            this.contractID = data["contractID"];
            this.transactionID = data["transactionID"];
            this.businessContractDTO = data["businessContractDTO"] ? Profile.fromJS(data["businessContractDTO"]) : <any>undefined;
            this.transactionTime = data["transactionTime"] ? new Date(data["transactionTime"].toString()) : <any>undefined;
            this.transactionConfirmation = data["transactionConfirmation"] ? TransactionConfirmation.fromJS(data["transactionConfirmation"]) : <any>undefined;
            this.name = data["name"];
            this.bindingId = data["bindingId"];
        }
    }

    static fromJS(data: any): ContractTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActiveTransaction"] = this.isActiveTransaction;
        data["contractID"] = this.contractID;
        data["transactionID"] = this.transactionID;
        data["businessContractDTO"] = this.businessContractDTO ? this.businessContractDTO.toJSON() : <any>undefined;
        data["transactionTime"] = this.transactionTime ? this.transactionTime.toISOString() : <any>undefined;
        data["transactionConfirmation"] = this.transactionConfirmation ? this.transactionConfirmation.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["bindingId"] = this.bindingId;
        return data;
    }
}

export interface IContractTransaction {
    id?: string | undefined;
    isActiveTransaction?: boolean | undefined;
    contractID?: string | undefined;
    transactionID?: string | undefined;
    businessContractDTO?: Profile | undefined;
    transactionTime?: Date | undefined;
    transactionConfirmation?: TransactionConfirmation | undefined;
    name?: string | undefined;
    bindingId?: string | undefined;
}

export class TransactionConfirmation implements ITransactionConfirmation {
    blockHash?: string | undefined;
    blockNumber?: string | undefined;
    ledgerAddress?: string | undefined;
    logs?: Log[] | undefined;
    transactionHash?: string | undefined;
    transactionIndex?: string | undefined;
    message?: Any | undefined;
    name?: string | undefined;
    proxyId?: string | undefined;

    constructor(data?: ITransactionConfirmation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.blockHash = data["blockHash"];
            this.blockNumber = data["blockNumber"];
            this.ledgerAddress = data["ledgerAddress"];
            if (data["logs"] && data["logs"].constructor === Array) {
                this.logs = [] as any;
                for (let item of data["logs"])
                    this.logs!.push(Log.fromJS(item));
            }
            this.transactionHash = data["transactionHash"];
            this.transactionIndex = data["transactionIndex"];
            this.message = data["message"] ? Any.fromJS(data["message"]) : <any>undefined;
            this.name = data["name"];
            this.proxyId = data["proxyId"];
        }
    }

    static fromJS(data: any): TransactionConfirmation {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionConfirmation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockHash"] = this.blockHash;
        data["blockNumber"] = this.blockNumber;
        data["ledgerAddress"] = this.ledgerAddress;
        if (this.logs && this.logs.constructor === Array) {
            data["logs"] = [];
            for (let item of this.logs)
                data["logs"].push(item.toJSON());
        }
        data["transactionHash"] = this.transactionHash;
        data["transactionIndex"] = this.transactionIndex;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["proxyId"] = this.proxyId;
        return data;
    }
}

export interface ITransactionConfirmation {
    blockHash?: string | undefined;
    blockNumber?: string | undefined;
    ledgerAddress?: string | undefined;
    logs?: Log[] | undefined;
    transactionHash?: string | undefined;
    transactionIndex?: string | undefined;
    message?: Any | undefined;
    name?: string | undefined;
    proxyId?: string | undefined;
}

export class Log implements ILog {
    logIndex?: string | undefined;
    transactionIndex?: string | undefined;
    transactionHash?: string | undefined;
    blockHash?: string | undefined;
    blockNumber?: string | undefined;
    address?: string | undefined;
    data?: string | undefined;
    type?: string | undefined;
    topics?: string[] | undefined;

    constructor(data?: ILog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.logIndex = data["logIndex"];
            this.transactionIndex = data["transactionIndex"];
            this.transactionHash = data["transactionHash"];
            this.blockHash = data["blockHash"];
            this.blockNumber = data["blockNumber"];
            this.address = data["address"];
            this.data = data["data"];
            this.type = data["type"];
            if (data["topics"] && data["topics"].constructor === Array) {
                this.topics = [] as any;
                for (let item of data["topics"])
                    this.topics!.push(item);
            }
        }
    }

    static fromJS(data: any): Log {
        data = typeof data === 'object' ? data : {};
        let result = new Log();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logIndex"] = this.logIndex;
        data["transactionIndex"] = this.transactionIndex;
        data["transactionHash"] = this.transactionHash;
        data["blockHash"] = this.blockHash;
        data["blockNumber"] = this.blockNumber;
        data["address"] = this.address;
        data["data"] = this.data;
        data["type"] = this.type;
        if (this.topics && this.topics.constructor === Array) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        return data;
    }
}

export interface ILog {
    logIndex?: string | undefined;
    transactionIndex?: string | undefined;
    transactionHash?: string | undefined;
    blockHash?: string | undefined;
    blockNumber?: string | undefined;
    address?: string | undefined;
    data?: string | undefined;
    type?: string | undefined;
    topics?: string[] | undefined;
}

export class Any implements IAny {
    typeUrl?: string | undefined;
    value?: number[] | undefined;

    constructor(data?: IAny) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeUrl = data["typeUrl"];
            if (data["value"] && data["value"].constructor === Array) {
                this.value = [] as any;
                for (let item of data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): Any {
        data = typeof data === 'object' ? data : {};
        let result = new Any();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeUrl"] = this.typeUrl;
        if (this.value && this.value.constructor === Array) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IAny {
    typeUrl?: string | undefined;
    value?: number[] | undefined;
}


export enum BasicProfileItemApplicationType {
    _0 = 0,
    _1 = 1,
}

export enum HealthcarePlanHealthcareStatus {
    NotAssigned = 0,
    Assigned = 1,
    Approved = 2,
    Enrolled = 3,
}

export namespace HealthcarePlanHealthcareStatus {
    export function keys(): Array<string> {
        let keys = Object.keys(HealthcarePlanHealthcareStatus);
        return keys.slice(keys.length / 2, keys.length - 1);
    }
}

export enum HealthcarePlanCarePlanEligibilityStatus {
    Pending = 0,
    Mandatory = 1,
    Voluntary = 2,
    InElegible = 3,
}

export namespace HealthcarePlanCarePlanEligibilityStatus {
    export function keys(): Array<string> {
        let keys = Object.keys(HealthcarePlanCarePlanEligibilityStatus);
        return keys.slice(keys.length / 2, keys.length - 1);
    }
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}